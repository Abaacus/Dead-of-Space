// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct MeshData
{
	float3 chunkSize;
	float3 vertices;
	int tris;
};

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<MeshData> dataBuffer;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
		/*float3 meshVertices = float3[8 * chunkSize.x * chunkSize.y * chunkSize.z];
		int[]
		meshTriangles = new
		int[6 * meshVertices.Length];
		Mesh mesh = new
		Mesh();

		int vertIndex = 0;
		for (int x = 0; x < chunkSize.x; x++)
		{
			for (int y = 0; y < chunkSize.y; y++)
			{
				for (int z = 0; z < chunkSize.z; z++)
				{
					int[]
					newEdgePoints = Table.GetEdgeTableRow(GetTableIndex(new
					int[]
					{
						vertexData[x + chunkOrigin.x, y + chunkOrigin.y, z + chunkOrigin.z],
                        vertexData[x + chunkOrigin.x + 1, y + chunkOrigin.y, z + chunkOrigin.z],
                        vertexData[x + chunkOrigin.x + 1, y + chunkOrigin.y, z + chunkOrigin.z + 1],
                        vertexData[x + chunkOrigin.x, y + chunkOrigin.y, z + chunkOrigin.z + 1],
                        vertexData[x + chunkOrigin.x, y + chunkOrigin.y + 1, z + chunkOrigin.z],
                        vertexData[x + chunkOrigin.x + 1, y + chunkOrigin.y + 1, z + chunkOrigin.z],
                        vertexData[x + chunkOrigin.x + 1, y + chunkOrigin.y + 1, z + chunkOrigin.z + 1],
                        vertexData[x + chunkOrigin.x, y + chunkOrigin.y + 1, z + chunkOrigin.z + 1]

					}));

					if (newEdgePoints.Length > 0)
					{
						Vector3 cubePos = new
						Vector3(x, y, z);

						for (int i = 0; i < newEdgePoints.Length; i++)
						{
							AddVertex(ref
							meshVertices, newEdgePoints[i], cubePos, vertIndex);
							meshTriangles[vertIndex] = vertIndex;
							vertIndex++;
						}
					}
				}
			}
		}*/
	}
